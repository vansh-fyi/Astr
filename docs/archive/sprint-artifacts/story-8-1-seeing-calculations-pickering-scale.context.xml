<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>8</epicId>
    <storyId>8.1</storyId>
    <title>Seeing Calculations (Pickering Scale)</title>
    <status>drafted</status>
    <generatedAt>2025-11-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/story-8-1-seeing-calculations-pickering-scale.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Stargazer</asA>
    <iWant>to see atmospheric "Seeing" quality on a 1-10 scale</iWant>
    <soThat>I know if conditions are stable for planetary observation</soThat>
    <tasks>
      - Task 1: Research & Algorithm Design (AC: #2, #4)
        - 1.1: Document Pickering scale research in `docs/calculations.md`
        - 1.2: Define heuristic algorithm in code comments
      - Task 2: Data Integration (AC: #3)
        - 2.1: Modify `WeatherRepository` to parse additional Open-Meteo fields (wind speed)
        - 2.2: Create `SeeingCalculator` service in `lib/core/services/`
      - Task 3: Seeing Calculation Logic (AC: #4, #5)
        - 3.1: Implement base score + penalty/bonus logic
        - 3.2: Write unit tests in `test/core/services/seeing_calculator_test.dart`
      - Task 4: UI Display (AC: #1, #6)
        - 4.1: Update `AtmosphericsSheet` widget (add Seeing row)
        - 4.2: Update `AtmosphericsProvider` state (add seeing fields)
      - Task 5: Documentation (AC: #2, #4)
        - 5.1: Update `docs/calculations.md` with Atmospheric Seeing section
    </tasks>
  </story>

  <acceptanceCriteria>
    1. **Pickering Scale Display (1-10)**
       - UI displays Seeing quality as integer 1-10 with descriptive label
       - Labels: 1-2 "Extremely Poor", 3-4 "Poor", 5-6 "Fair", 7-8 "Good", 9-10 "Excellent"
       - Displayed in Atmospheric Drawer alongside Cloud Cover, Humidity, Temperature

    2. **Heuristic Calculation Model**
       - System estimates Seeing using meteorological data (temperature, humidity, wind speed)
       - Algorithm documented in code with research citations
       - Note: Pickering scale is observational; this implementation uses simplified heuristic

    3. **Data Sources**
       - Temperature (2m): Open-Meteo `temperature_2m` (°C)
       - Humidity: Open-Meteo `relativehumidity_2m` (%)
       - Wind Speed: Open-Meteo `windspeed_10m` (km/h)
       - All data fetched from existing Open-Meteo API call (no additional requests)

    4. **Algorithm Logic (Documented)**
       - Base Score: Start at 10 (perfect seeing)
       - Temperature Gradient Penalty: variance > 5°C (-2), > 3°C (-1)
       - Wind Speed Penalty: >30 km/h (-3), >20 km/h (-2), >10 km/h (-1)
       - Humidity Bonus: >70% with stable temp (+1)
       - Final Score: Clamp to 1-10 range

    5. **Unit Testing**
       - Test calm conditions → Seeing ≥ 8
       - Test windy conditions → Seeing ≤ 4
       - Test extreme poor → Seeing = 1-2

    6. **UI Integration**
       - Display in `AtmosphericsSheet`
       - Format: "Seeing: 7 (Good)" with color coding (Red 1-4, Yellow 5-7, Green 8-10)
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR15 - System & Data</section>
        <snippet>Open-Meteo API for weather data (temperature, humidity, cloud cover). 7-day forecast capability. Offline functionality for ephemeris calculations.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Pattern C - The Proxy Pattern</section>
        <snippet>Free/keyless APIs (Open-Meteo) may be called directly from Flutter. Backend proxy not required for MVP (<1,000 users).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Pattern D - Backend Data Services</section>
        <snippet>Weather data from Open-Meteo direct client calls (zero cost). Result<Failure, Type> pattern enforced for all repository methods.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epics Breakdown</title>
        <section>Epic 8 - Calculation Accuracy & Math Transparency</section>
        <snippet>Story 8.1 implements Seeing calculations using Pickering scale (1-10). Data sourced from Open-Meteo (humidity, wind, temperature). Heuristic algorithm approximates observational Pickering scale.</snippet>
      </doc>
      <doc>
        <path>docs/backend-architecture-research.md</path>
        <title>Backend Architecture Research</title>
        <section>Open-Meteo Direct Calls (MVP)</section>
        <snippet>Open-Meteo free tier: 10,000 requests/day. Direct Flutter calls acceptable for MVP. Migrate to Cloudflare Workers proxy when user count >1,000.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>lib/features/dashboard/data/repositories/weather_repository_impl.dart</path>
        <kind>repository</kind>
        <symbol>WeatherRepositoryImpl</symbol>
        <lines>1-23</lines>
        <reason>Current implementation fetches cloud cover from Open-Meteo. Must be extended to parse windspeed_10m, temperature_2m, relativehumidity_2m for Seeing calculations.</reason>
      </artifact>
      <artifact>
        <path>lib/features/dashboard/data/datasources/open_meteo_weather_service.dart</path>
        <kind>datasource</kind>
        <symbol>OpenMeteoWeatherService</symbol>
        <lines>N/A</lines>
        <reason>Handles Open-Meteo API requests. Verify windspeed_10m parameter is included in API call. If not, add to hourly query parameters.</reason>
      </artifact>
      <artifact>
        <path>lib/features/dashboard/presentation/widgets/atmospherics_sheet.dart</path>
        <kind>widget</kind>
        <symbol>AtmosphericsSheet</symbol>
        <lines>7-133</lines>
        <reason>UI component displaying atmospheric conditions (Seeing, Darkness, Humidity, Temp). Currently shows mock data (line 91-100). Must integrate real Seeing data from provider.</reason>
      </artifact>
      <artifact>
        <path>lib/features/dashboard/domain/entities/weather.dart</path>
        <kind>entity</kind>
        <symbol>Weather</symbol>
        <lines>N/A</lines>
        <reason>Weather entity model. Must be extended to include temperatureC, humidity, windSpeed fields for Seeing calculation input.</reason>
      </artifact>
    </code>

    <dependencies>
      <flutter>
        <package>fpdart</package>
        <version>Latest (functional programming, Either type)</version>
        <usage>Result pattern (Either<Failure, Success>) for weather repository</usage>
      </flutter>
      <flutter>
        <package>http</package>
        <version>Latest</version>
        <usage>Open-Meteo API calls (existing)</usage>
      </flutter>
      <flutter>
        <package>riverpod</package>
        <version>Latest (2.x)</version>
        <usage>State management for atmospherics provider</usage>
      </flutter>
      <flutter>
        <package>logger</package>
        <version>Latest</version>
        <usage>Error logging for API failures</usage>
      </flutter>
    </dependencies>
  </artifacts>

  <constraints>
    - **Result Pattern Mandatory:** All repository methods must return `Future<Either<Failure, Type>>` (fpdart)
    - **Clean Architecture:** Domain layer entities must not depend on data layer implementations
    - **Weather API:** Open-Meteo direct client calls acceptable for MVP; no backend proxy required
    - **Heuristic Algorithm:** Pickering scale is observational; implementation uses meteorological proxy (temp, wind, humidity)
    - **No Additional API Calls:** Use existing Open-Meteo request; add windspeed_10m parameter if missing
    - **UI Consistency:** Follow `GlassPanel` pattern for atmospheric metrics display (existing pattern in codebase)
    - **Color Coding:** Red (1-4 Poor), Yellow (5-7 Fair), Green (8-10 Excellent) for seeing quality indicator
  </constraints>

  <interfaces>
    <interface>
      <name>IWeatherRepository.getWeather</name>
      <kind>Repository Method</kind>
      <signature>Future&lt;Either&lt;Failure, Weather&gt;&gt; getWeather(GeoLocation location)</signature>
      <path>lib/features/dashboard/domain/repositories/i_weather_repository.dart</path>
    </interface>
    <interface>
      <name>OpenMeteoWeatherService.getCloudCover</name>
      <kind>Data Source Method</kind>
      <signature>Future&lt;List&lt;double&gt;&gt; getCloudCover(GeoLocation location)</signature>
      <path>lib/features/dashboard/data/datasources/open_meteo_weather_service.dart</path>
    </interface>
    <interface>
      <name>Open-Meteo Forecast API</name>
      <kind>REST Endpoint</kind>
      <signature>GET https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&hourly=temperature_2m,relativehumidity_2m,cloudcover,windspeed_10m&forecast_days=7</signature>
      <path>External API</path>
    </interface>
    <interface>
      <name>SeeingCalculator (NEW)</name>
      <kind>Service Class (To Be Created)</kind>
      <signature>
        class SeeingCalculator {
          /// Calculates Pickering Seeing score (1-10) from weather data
          /// Input: List&lt;WeatherDataPoint&gt; hourly forecast
          /// Output: (int score, String label)
          (int, String) calculateSeeing(List&lt;WeatherDataPoint&gt; data);
        }
      </signature>
      <path>lib/core/services/seeing_calculator.dart</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Flutter unit tests using `flutter_test` package. Repository tests use mocks (mockito). Service tests validate algorithm logic with known input/output scenarios. Widget tests verify UI displays data correctly. Test files mirror source structure (`test/` directory). Use `test` command: `flutter test`.
    </standards>
    <locations>
      - test/core/services/ (for SeeingCalculator unit tests)
      - test/features/dashboard/data/repositories/ (for WeatherRepository tests)
      - test/features/dashboard/presentation/widgets/ (for AtmosphericsSheet widget tests)
    </locations>
    <ideas>
      - AC#5: Test calm conditions (temp variance < 3°C, wind < 5 km/h, humidity 60%) → Seeing score ≥ 8
      - AC#5: Test windy conditions (wind > 30 km/h, temp variance > 5°C) → Seeing score ≤ 4
      - AC#5: Test extreme poor (wind 40 km/h, temp variance 8°C, humidity 30%) → Seeing score 1-2
      - AC#4: Test score clamping (ensure output always 1-10, never exceeds bounds)
      - AC#3: Test null/missing data handling (partial Open-Meteo response) → Graceful degradation
      - AC#1: Widget test - verify Seeing label text matches score (e.g., score 7 → "Good")
      - AC#6: Widget test - verify color coding (Red for 1-4, Yellow for 5-7, Green for 8-10)
    </ideas>
  </tests>
</story-context>
