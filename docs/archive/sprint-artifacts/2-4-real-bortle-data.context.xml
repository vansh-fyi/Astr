<story-context id="2-4-real-bortle-data.context" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.4</storyId>
    <title>Real Visibility Data</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-29</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-4-real-bortle-data.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Stargazer</asA>
    <iWant>to see the actual light pollution data as a "Visibility Scale"</iWant>
    <soThat>I have a scientifically accurate but easy-to-understand metric</soThat>
    <tasks>
      - [ ] Define `LightPollution` entity (visibilityIndex, brightnessRatio, mpsas, source: precise/fallback).
      - [ ] Define `ILightPollutionService` interface.
      - [ ] Refactor `BortleScale` enum to `VisibilityScale` (or map to it).
      - [ ] Implement `BinaryTileService` to fetch `.dat.gz` from `djlorenz.github.io`.
      - [ ] Implement GZIP decompression (using `archive` package).
      - [ ] Implement Delta-Decoding logic (reverse-engineered algorithm).
      - [ ] Implement `compressed2full` conversion logic.
      - [ ] Bundle `assets/maps/world2024_low3.png`.
      - [ ] Implement `PngMapService` to load image and read pixel color.
      - [ ] Implement Lat/Long -> Pixel (Equirectangular) projection logic.
      - [ ] Map Color -> Visibility Value (0-9).
      - [ ] Implement `LightPollutionRepository` that orchestrates the Hybrid strategy.
      - [ ] Update `BortleProvider` (rename to `VisibilityProvider`?).
      - [ ] Update `BortleBar` widget to show "Visibility Scale" and use new data.
      - [ ] Unit Test: Binary decoding logic.
      - [ ] Unit Test: PNG projection logic.
      - [ ] Integration Test: Repository fallback mechanism.
    </tasks>
  </story>

  <acceptanceCriteria>
    - **AC-2.4.1** **Hybrid Data Source:** System attempts to fetch precise data from Binary Tiles first; falls back to PNG map if offline/unavailable.
    - **AC-2.4.2** **Binary Tile Decoding:** Correctly downloads, unzips, and decodes the `.dat.gz` tile for the user's location.
    - **AC-2.4.3** **PNG Fallback:** Correctly maps Lat/Long to pixel coordinates on the bundled `world2024_low3.png` and extracts a rough value.
    - **AC-2.4.4** **Data Accuracy:** Calculated "Brightness Ratio" matches the website's output for a known location (within reasonable margin).
    - **AC-2.4.5** **UI Update:** Renames "Bortle Scale" to "Visibility Scale" in the UI.
    - **AC-2.4.6** **Caching:** Cached binary tiles are used if available.
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR15</section>
        <snippet>Weather & Environmental Data: Real-time light pollution data.</snippet>
      </doc>
    </docs>
    <code>
      <item>
        <path>lib/features/dashboard/presentation/widgets/bortle_bar.dart</path>
        <kind>widget</kind>
        <symbol>BortleBar</symbol>
        <reason>Target for renaming and data integration.</reason>
      </item>
      <item>
        <path>lib/features/dashboard/domain/entities/bortle_scale.dart</path>
        <kind>entity</kind>
        <symbol>BortleScale</symbol>
        <reason>Needs refactoring or mapping to VisibilityScale.</reason>
      </item>
    </code>
    <dependencies>
      <dep>archive</dep>
      <dep>image</dep>
      <dep>http</dep>
      <dep>path_provider</dep>
    </dependencies>
  </artifacts>

  <constraints>
    - **Binary Format:** Tiles are 600x600. Filename: `binary_tile_{x}_{y}.dat.gz`. Logic: `tilex = floor(lonFromDateLine/5) + 1`, `tiley = floor((lat + 65)/5) + 1`. Data: 16-bit start value + 8-bit deltas.
    - **PNG Map:** Equirectangular projection. Lat: -90 to 90, Long: -180 to 180.
    - **UI:** Reuse existing Rive animation but change label to "Visibility Scale".
  </constraints>

  <interfaces>
    <interface>
      <name>Binary Tile API</name>
      <kind>HTTP</kind>
      <signature>GET https://djlorenz.github.io/astronomy/binary_tiles/2024/binary_tile_{x}_{y}.dat.gz</signature>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Unit tests for decoding logic are critical. Use a small mock binary buffer for testing.
    </standards>
    <locations>
      test/features/dashboard/data/
    </locations>
  </tests>
</story-context>
